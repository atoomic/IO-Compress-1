#!/usr/bin/perl

# TODO - if a nested  zip file is encrypted, next will bomb out with an unhelpful message

use strict;
use warnings;

# TODO - need to include the minimum version of IO::Uncompress::Unzip that works with this script.
use IO::Uncompress::Unzip qw($UnzipError) ;
use Getopt::Long;
use File::Basename;

sub progress;

my $VERSION = '0.001';

my %first  ;
my $opt_List = 0;
my $opt_One = 0;
my $opt_Pipe = 0;
my $opt_PipeWithName = 0;
my $opt_Quiet = 0;
my $opt_Overwrite  = 0;
my $opt_NeverOverwrite = 0;
my $opt_Verbose = 0; # TODO
my $opt_DestDir = './'; # TODO
my $opt_JunkPaths = 0; # TODO
my $opt_UnsafePath = 0 ;
my $opt_FixWindowsPath = 0;
my $opt_Wild_No_Span = 0;
my $extracting = 1;

my @zipExtensions = qw(zip jar war) ;
my $zipExtensionsRE = '(?:' . join('|', map { quotemeta }  @zipExtensions) . ')';

Getopt::Long::Configure ("bundling");
GetOptions (#'1'             => \$opt_One,
            'c'             =>  sub { $opt_PipeWithName = $opt_Pipe = 1; $opt_Quiet = 0 },
            #'d=s'           => \$opt_DestDir,
            #'j'             => \$opt_JunkPaths,
            'l'             => \$opt_List,
            'p'             =>  sub { $opt_Pipe = $opt_Quiet = 1 },
            'n'             => \$opt_NeverOverwrite,
            'o'             => \$opt_Overwrite,
            'q'             => \$opt_Quiet,
            'W|wild-no-span' => \$opt_Wild_No_Span,
            'help'          => \&Usage,
            'fix-windows-path'  => \$opt_FixWindowsPath,
            'unsafe-path'   => \$opt_UnsafePath,
            #'verbose'      => \$opt_Verbose,
            'version'       => sub { print "$VERSION\n"; exit 0 },
            )
  or Usage();

$extracting = ! ($opt_List || $opt_One) ;

Usage()
    if ! @ARGV;

my $zipfile = shift ;
my @want = @ARGV;
my %want = map { $_ => 1 } @want;
my $wantGlobRE  ;

$wantGlobRE = '^(?:' . join( '|', map { globToRegex($_) } @want) . ')$'
    if @want;

my $unzip = new IO::Uncompress::Unzip $zipfile
            or die "Cannot open '$zipfile': $UnzipError\n";

progress "Archive: $zipfile";
walk($unzip, []) ;

sub nextStream
{
    my $unzip = shift ;

    if (! $first{$unzip})
    {
        $first{$unzip} =1;
        return 1;
    }

    my $status = $unzip->nextStream();
    return undef
        if $status <= 0;

    return 1;
}

sub walk
{
    my $unzip  = shift ;
    my @unzip_path = @{ shift() };
    my $matchZip = shift ;

    while (nextStream($unzip))
    {
        my $hdrInfo = $unzip->getHeaderInfo();
        my $name = $hdrInfo->{Name};

        my $fullname = $matchZip ? join('/', @unzip_path, $name) : $name;

        my $isZip = isZipFile($unzip, $fullname) ;

        my $matched = 0;

        if ($wantGlobRE)
        {
            # warn "Matching against [$fullname]\n";
            $matched = 1
                if $fullname =~ /$wantGlobRE/ ;
        }
        else
        {
            # no matches specified, so want everything
            $matched = 1 ;
        }

        if ($matched)
        {

            if ($extracting && ! $isZip)
            {
                if ($opt_Pipe)
                {
                    progress "  extracting: " . join("/", @unzip_path, $name)
                        if $opt_PipeWithName ;

                    my $buff;
                    my $status;
                    while (($status = $unzip->read($buff)) > 0)
                    {
                        print $buff;
                    }
                }
                else
                {
                    # Extract to filesystem
                    use File::Path ;

                    if ($opt_FixWindowsPath)
                    {
                        $fullname =~ s/^[a-zA-Z]://;
                        $fullname =~ s#\\#/#g ;
                    }

                    my $isDir = $fullname =~ s#/+$##;
                    $fullname = canonicalPath($fullname)
                        if ! $opt_UnsafePath;

                    my $newname;
                    if (chkReplace($fullname, \$newname))
                    {
                        my $path = dirname $newname;

                        progress "  extracting: $newname";
                        if (! -d $path)
                        {
                            mkpath($path)
                                if length $path;
                        }

                        if ($isDir)
                        {
                            mkpath($newname)
                        }
                        else
                        {
                            open my $fh, '>', $newname
                                or die "Cannot open '$newname: $!\n" ;
                            binmode $fh;

                            my $buff;
                            my $status;
                            while (($status = $unzip->read($buff)) > 0)
                            {
                                print $fh $buff;
                            }
                        }
                    }
                }
            }

            # Listing options
            if ($opt_One)
            {
                print $name . "\n" ;
            }
            elsif ($opt_List)
            {
                # print "  " x (@unzip_path) . "$name\n" ;

                print join("/", @unzip_path, $name) . "\n";
            }

        }

        if ($isZip)
        {
            my $newunzip = new IO::Uncompress::Unzip $unzip
                or die "Cannot open '$name': $UnzipError\n";
            walk($newunzip, [@unzip_path, $extracting ? "$name.nested" : $name], 1);
        }
    }
}

sub isZipFile
{
    my $fh = shift;
    my $name = shift ;

    use IO::Compress::Zip::Constants ;

    my $buffer ;
    $fh->read($buffer, 4);
    $fh->ungetc($buffer);

    return 0
        if length $buffer < 4 ;

    my $sig = unpack("V", $buffer) ;
    #print "isZipFile $name: " . length($buffer) . " " . ($sig == ZIP_LOCAL_HDR_SIG ? 1 : 0) . " $sig " . "\n";

    return $sig == ZIP_LOCAL_HDR_SIG ;
}

sub progress
{
    return if $opt_Quiet;
    print "$_\n" for @_ ;
}

sub globToRegex
{
    my $string = shift ;

    my $inGlob = '';

    my $noPreBS = '(?<!\\\)' ; # no preceding backslash
    my $metachars = '.?';
    my $matchMetaRE = '[' . quotemeta($metachars) . ']';
    $matchMetaRE = "(?:\\*{1,2}|$matchMetaRE)";

    my %mapping = (
                # wildcard  Wild-no-span  default
                '*'  => { 1 => '[^/]*',  0 => '.*' },
                '?'  => { 1 => '[^/]',   0 => '.'  },
                '.'  => { 1 => '\.',     0 => '\.' },
                '**' => { 1 => '.*',     0 => '.*' },
                # '[' => '([',
                # '(' => '(',
                # ')' => ')',
           );

    # Multiple concatenated *'s don't make sense
    #$string =~ s#\*\*+#*# ;

    # TODO -- Allow space to delimit patterns?
    #my @strings = split /\s+/, $string ;
    #for my $str (@strings)
    my $out = '';
    my $depth = 0 ;

    while ($string =~ s/(.*?)$noPreBS($matchMetaRE)//)
    {
        $out .= quotemeta($1) ;
        $out .= $mapping{$2}{$opt_Wild_No_Span}
            if defined $mapping{$2};
    }

    $out .= quotemeta($string);

    return $out;
}

sub chkReplace
{
    my $filename = shift ;
    my $newFilename = shift ;

    # default is not to rename
    $$newFilename = $filename;

    return 1 if $opt_Overwrite ;
    return 0 if $opt_NeverOverwrite;

    my $got = '';
    while (1)
    {
        return 1
            if ! -e $filename ;

        while (1)
        {
            print "replace $filename? [y]es, [n]o, [A]ll, [N]one, [r]ename: ";
            $got = <STDIN>;
            chomp $got;

            last
                if $got !~ /[ynANr]/ ;

            print "error: invaid response [$got]\n";
        }

        return 1 if $got eq 'y';
        return 0 if $got eq 'n';

        if ($got eq 'A')
        {
            $opt_Overwrite = 1 ;
            return 1 ;
        }

        if ($got eq 'N')
        {
            $opt_NeverOverwrite = 1 ;
            return 1 ;
        }

        if ($got eq 'r')
        {
            print "new name: ";

            $filename = <STDIN>;
            chomp $filename;
            $$newFilename = $filename;
        }
    }
}


sub canonicalPath
{
    my $name = shift ;

    # Not an absolute path
    $name =~ s#^/+## ;

    # Remove trailing slash
    # $name =~ s#/+$## ;

    $name =~ s#/+#/#g ;

    # Drop any ".." and "." paths
    # Use of ".." is unsafe
    my @paths = split '/', $name ;
    my @have =  grep { $_ ne '.' } @paths ;

    @have =  grep {  $_ ne '..' } @paths
        if ! $opt_UnsafePath;

    return join '/', @have ;

    # use Perl::OSType;
    # my $type = Perl::OSType::os_type();
    # if ( $type eq 'Unix' )
    # {
    # }
    # # TODO Win32
}

sub Usage
{
    die <<EOM;
Usage: nested-unzip [OPTIONS] file.zip [list]

Unzip a zip file that itself contains zip files, nested to any level.

OPTIONS

 -c     Extract file to stdout, prefix with name as extracting
 -p     Extract file to stdout
 -W     Modify pattern matching so ? and * do not match
        directory separator /, but ** does.
        Allows matching at specific directory levels

 --fix-windows-path     Remove drive letter & change path separator from "\" to "/"

EOM
}

__END__
=head1 NAME

nested-unzip - uncompress zip files that also contain zip files

=head1 SYNOPSIS

    nested-unzip [opts] file.zip [list]

=head1 DESCRIPTION

This program is used to uncompress zip files that themselves contain other zip files.
Those nested zip files can in turn embed more zip files.
The program can cope with Zip files can be nested to any depth.

To paraphrase the well-known poem "Siphonaptera"

    Nested zips have little zips upon their backs to bite 'em,
    And little zips have lesser zips, and so ad infinitum.

Where possible, and it makes sense, the interface has been written to match the Linux unzip program.

The program works by reading the zip file in streaming mode,
so no temporary files are created when walking a nested tree of zip files.

=head2 Default Behavior

The default behavior of the program is to uncompress all
the nested zip files into a directory tree that mirrors the zip file. The directories created for each of the nested
zip files has the string ".nested" appended.

=head2 OPTIONS

=over 5

=item -c

Write the contents to stdout. Prefix with name as extracting.

=item -l

List the contents of the nested zip file.

=item -p

Write the contents to stdout.

=item -W

=item --wild-no-span

Changes the behavior of the wildcard

=item  --unsafe-path

Allow extraction of files that include unsafe paths. Not recommended.

TODO - add something about what an unsafe path is.

=item  --fix-windows-path

When this option is enabled it will make the following changes to all filenames before writing
to the filesystem

=over 5

=item *
Remove any leading drive letter.

=item *
Convert all "\" characters to "/" .

=back

For example

    Stored in Zip File  Output when "fix-windows-path" enabled
    ------------------  ------------------------------------
    c:\abc.txt          abc.txt
    one\two\three.txt   one/two/three.txt


See L<Zip files that contain Windows Paths> for more details.


=item  --version

Display version number [$VERSION]

=item --help

Display help

=back

=head1 FAQ

=head2 Zip files that contain Windows Paths

Short answer - include the C<--fix-windows-path> option when running this program.

Here is the longer answer.

A well-known problem with some zip implementations on Windows is they
will write a windows-native path into the zip file (e.g. "C:\abc\def\my.txt").

This is a badly-formed zip file. The Zip specification,
L<APPNOTE.TXT|https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT>,
is very clear on how paths should be stored in a zip file.

       4.4.17.1 The name of the file, with optional relative path.
       The path stored MUST NOT contain a drive or
       device letter, or a leading slash.  All slashes
       MUST be forward slashes '/' as opposed to
       backwards slashes '\' for compatibility with Amiga
       and UNIX file systems etc.  If input came from stanard
       input, there is no file name field.

The problem comes when unzipping one of these badly-formed zip files.
Consider the zip file "bad.zip", shown below, that contains a windows-native path.

    $ unzip -l bad.zip
    Archive:  bad.zip
      Length      Date    Time    Name
    ---------  ---------- -----   ----
           27  03-10-2020 12:01   C:\abc\my.txt
    ---------                     -------
           27                     1 file

If this zipfile is extracted on a Linux-like operating system using the standard
unzip program, it will do the following

    $ unzip bad.zip
    Archive:  bad.zip
      inflating: C:\abc\my.txt

    $ ls -l *.txt
    -rw-r--r-- 1 xxx yyy 27 Mar 10 12:01 C:\abc\my.txt

Instead of creating
a sub-directory "abc" and storing "my.txt" in that directory, it thinks
that "C:\abc\my.txt" is the name of  file.

The C<--fix-windows-path> option was designed to fix these paths.
It will convert all filnames into Linux/Unix format before writing
to the filesystem, by makes these changes

=over 5

=item *
Remove any leading drive letter.

=item *
Convert all "\" characters to "/" .

=back


=head1 EXAMPLES

=head1 LIMITATIONS

=head1 SUPPORT

General feedback/questions/bug reports should be sent to
L<https://github.com/pmqs/IO-Compress/issues> (preferred) or
L<https://rt.cpan.org/Public/Dist/Display.html?Name=IO-Compress>.

=head1 AUTHOR

Paul Marquess F<pmqs@cpan.org>.

=head1 COPYRIGHT

Copyright (c) 2020 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.