#!/usr/bin/perl

# TODO - if a nested  zip file is encrypted, next will bomb out with an unhelpful message

use strict;
use warnings;

# TODO - need to include the minimum version of IO::Uncompress::Unzip that works with this script.
use IO::Uncompress::Unzip qw($UnzipError) ;
use Getopt::Long;
# use Text::Glob qw(glob_to_regex_string);
use File::Basename;

my $VERSION = '0.001';

my %first  ;
my $list = 0;
my $one = 0;
my $pipe = 0;
my $verbose = 0; # TODO
my $destDir = './'; # TODO
my $junkPaths = 0; # TODO

GetOptions ('1'         => \$one,
            'l'         => \$list,
            'p'         => \$pipe,
            'd=s'       => \$destDir,
            'j'         => \$junkPaths,
            'verbose'   => \$verbose,
            'version'   => sub { print "$VERSION\n"; exit 0 },
            'help'      => \&Usage,)
  or Usage();

usage()
    if ! @ARGV;

my $zipfile = shift ;
my @want = @ARGV;
my %want = map { $_ => 1 } @want;
# my $wantRE = join '|', map { toRegex($_) } @want;
my $wantGlobRE  ;

# print join "\n", globToRegex($_) for @want; exit;
# $wantGlobRE = '^(?:' . join( '|', map { glob_to_regex_string($_) } @want) . ')$'
#     if @want;

$wantGlobRE = '^(?:' . join( '|', map { globToRegex($_) } @want) . ')$'
    if @want;

my $unzip = new IO::Uncompress::Unzip $zipfile
            or die "Cannot open '$zipfile': $UnzipError\n";

walk($unzip, []) ;

sub nextStream
{
    my $unzip = shift ;

    if (! $first{$unzip})
    {
        $first{$unzip} =1;
        return 1;
    }

    my $status = $unzip->nextStream();
    return undef
        if $status <= 0;

    return 1;
}

sub walk
{
    my $unzip  = shift ;
    my @unzip_path = @{ shift() };
    my $matchZip = shift ;

    while (nextStream($unzip))
    {
        my $hdrInfo = $unzip->getHeaderInfo();
        my $name = $hdrInfo->{Name};

        my $fullname = $matchZip ? join('/', @unzip_path, $name) : $name;

        if ($name =~ /\.zip$/i)
        {
            my $newunzip = new IO::Uncompress::Unzip $unzip
                or die "Cannot open '$name': $UnzipError\n";
            walk($newunzip, [@unzip_path, $name], 1);
            next ;
        }

        my $matched = 0;
        if ($wantGlobRE)
        {
            # warn "Matching against [$fullname]\n";
            $matched = 1
                if $fullname =~ /$wantGlobRE/ ;
        }
        else
        {
            $matched  = 1 ;
        }

        # my $matched = ! @want || $want{$name} || $matchZip ;
        my $matchZipNext = $matchZip || ( $matched && $name =~ /\.zip$/i );

        if ($matched)
        {
            if ($pipe)
            {
                my $buff;
                my $status;
                while (($status = $unzip->read($buff)) > 0)
                {
                    print $buff;
                }
            }
            elsif ($one)
            {
                print $name . "\n" ;
            }
            elsif ($list)
            {
                # print "  " x (@unzip_path) . "$name\n" ;

                print join(" : ", @unzip_path, $name) . "\n";
            }
            else
            {
                # extract
                use File::Path qw(make_path);

                my $path = dirname $fullname;
                make_path($path)
                    if length $path;

                open my $fh, '>', $fullname
                    or die "Cannot open '$fullname: $!\n" ;
                binmode $fh;

                my $buff;
                my $status;
                while (($status = $unzip->read($buff)) > 0)
                {
                    print $fh $buff;
                }
            }
        }
    }
}



sub globToRegex
{
    my $string = shift ;

    my $inGlob = '';

    # our ($noPreBS, $metachars, $matchMetaRE, %mapping, %wildCount);
    my $noPreBS = '(?<!\\\)' ; # no preceding backslash
    my $metachars = '.?';
    my $matchMetaRE = '[' . quotemeta($metachars) . ']';
    $matchMetaRE = "(?:\\*{1,2}|$matchMetaRE)";
    # warn "MM [$matchMetaRE]\n";

    my %mapping = (
                '*' => '[^/]*',
                '?' => '[^/]',
                '.' => '\.',
                '**' => '.*',
                # '[' => '([',
                # '(' => '(',
                # ')' => ')',
           );

    # Multiple concatenated *'s don't make sense
    #$string =~ s#\*\*+#*# ;

    # TODO -- Allow space to delimit patterns?
    #my @strings = split /\s+/, $string ;
    #for my $str (@strings)
    my $out = '';
    my $depth = 0 ;

    while ($string =~ s/(.*?)$noPreBS($matchMetaRE)//)
    {
        $out .= quotemeta($1) ;
        $out .= $mapping{$2}
            if defined $mapping{$2};
    }

    $out .= quotemeta($string);

    return $out;
}

sub usage
{
    die <<EOM;
Usage: nested-unzip [OPTIONS] file.zip [list]

Unzip a zip file that itself contains zip files, nested to any level.

OPTIONS

EOM
}

__END__
=head1 NAME

nested-unzip - uncompress zip files that also contain zip files

=head1 SYNOPSIS

    nested-unzip [opts] file.zip [list]

=head1 DESCRIPTION

This program is used to uncompress zip files that themselves contain other zip files.
Those nested zip files can in turn also have zip files embedded.
Zip files can be nested to any depth.

To paraphrase the well-known poem "Siphonaptera"

    Great zips have little zips upon their backs to bite 'em,
    And little zips have lesser zips, and so ad infinitum.

Where possible, and it makes sense, the interface has been written to match the Linux unzip program.

=head2 Default Behavior

The default behavior of the program is to uncompress all
the nested zip files into a directory tree that mirrors the top-level zip file. The directories created for each of the nested
zip files is named ...

The nested zip files themselves are not extracted unless option xxx is enabled.

=head2 OPTIONS

=over 5

=item  -version

Display version number [$VERSION]

=item -help

Display help

=back

=head1 LIMITATIONS

=head1 SUPPORT

General feedback/questions/bug reports should be sent to
L<https://github.com/pmqs/IO-Compress/issues> (preferred) or
L<https://rt.cpan.org/Public/Dist/Display.html?Name=IO-Compress>.

=head1 AUTHOR

Paul Marquess F<pmqs@cpan.org>.

=head1 COPYRIGHT

Copyright (c) 2020 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.