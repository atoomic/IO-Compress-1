#!/usr/bin/perl

# TODO - if a nested  zip file is encrypted, next will bomb out with an unhelpful message

use strict;
use warnings;

# TODO - need to include the minimum version of IO::Uncompress::Unzip that works with this script.
use IO::Uncompress::Unzip qw($UnzipError) ;
use Getopt::Long;
use File::Basename;
use File::Path ;

sub progress;

my $VERSION = '0.001';

my %first  ;
my $opt_List = 0;
my $opt_One = 0;
my $opt_Pipe = 0;
my $opt_PipeWithName = 0;
my $opt_Quiet = 0;
my $opt_Overwrite  = 0;
my $opt_NeverOverwrite = 0;
my $opt_Verbose = 0; # TODO
my $opt_DestDir ;
my $opt_JunkPaths = 0; # TODO
my $opt_UnsafePath = 0 ;
my $opt_FixWindowsPath = 0;
my $opt_Wild_No_Span = 0;
my $opt_HideNestedZip = 0;
my @opt_ZipWildcards;
my @opt_ZipWildcards_Default = qw( **.zip) ;

my $extracting = 1;

my @zipExtensions = qw(zip jar war) ;
my $zipExtensionsRE = '(?:' . join('|', map { quotemeta }  @zipExtensions) . ')';

Getopt::Long::Configure ("bundling");
GetOptions (
            # unzip equivalent options
            #'1'                => \$opt_One,
            'c|to-stdout'       =>  sub { $opt_PipeWithName = $opt_Pipe = 1; $opt_Quiet = 0 },
            'd|extract-dir=s'   => \$opt_DestDir,
            #'j|junk-dirs=i{0}' => \$opt_JunkPaths,
            'l|list'            => \$opt_List,
            'p|pipe-to-stdout'  =>  sub { $opt_Pipe = $opt_Quiet = 1 },
            'n|never-overwrite' => \$opt_NeverOverwrite,
            'o|overwrite'       => \$opt_Overwrite,
            'q|quiet'           => \$opt_Quiet,
            'W|wild-no-span'    => \$opt_Wild_No_Span,
            'h|help'            => \&Usage,
            'do-double-dots'    => \$opt_UnsafePath,
            #'v|verbose'        => \$opt_Verbose,

            # specific to this program
            'fix-windows-path'  => \$opt_FixWindowsPath,
            'hide-nested-zip'   => \$opt_HideNestedZip,
            'version'           => sub { print "$VERSION\n"; exit 0 },
            'zip-wildcard=s'    => \@opt_ZipWildcards,
            )
  or Usage();


Usage()
    if ! @ARGV;

$extracting = ! ($opt_List || $opt_One) ;

my $zipfile = shift ;
my @want = @ARGV;
my %want = map { $_ => 1 } @want;
my $wantGlobRE  ;

$wantGlobRE = '^(?:' . join( '|', map { globToRegex($_) } @want) . ')$'
    if @want;

my $unzip = new IO::Uncompress::Unzip $zipfile
            or die "Cannot open '$zipfile': $UnzipError\n";

if (defined $opt_DestDir)
{
    mkpath $opt_DestDir
        or die "Cannot create directory '$opt_DestDir': $!\n";

    chdir $opt_DestDir
        or die "Cannot chdir to '$opt_DestDir': $!\n"
}

# Zip Wildcards
push @opt_ZipWildcards, '**.zip'
    unless @opt_ZipWildcards;

my $opt_ZipWildcards = '^(?:' . join( '|', map { globToRegex($_) } @opt_ZipWildcards) . ')$';

progress "Archive: $zipfile";
walk($unzip, []) ;

exit 0;

sub nextStream
{
    my $unzip = shift ;

    if (! $first{$unzip})
    {
        $first{$unzip} =1;
        return 1;
    }

    my $status = $unzip->nextStream();
    return undef
        if $status <= 0;

    return 1;
}

sub walk
{
    my $unzip  = shift ;
    my @unzip_path = @{ shift() };
    my $matchZip = shift ;

    while (nextStream($unzip))
    {
        my $hdrInfo = $unzip->getHeaderInfo();
        my $name = $hdrInfo->{Name};
        my $dosTime = $hdrInfo->{Time};
        my $extraFields = $hdrInfo->{ExtraField};
        my $extracted = 0;

        my $fullname = $matchZip ? join('/', @unzip_path, $name) : $name;

        my $isZip = isZipFile($unzip, $fullname) ;

        my $matched = 0;

        if ($wantGlobRE)
        {
            # warn "Matching against [$fullname]\n";
            $matched = 1
                if $fullname =~ /$wantGlobRE/ ;
        }
        else
        {
            # no matches specified, so want everything
            $matched = 1 ;
        }

        $matched = 0
            if $isZip && $opt_HideNestedZip ;

        if ($matched)
        {

            if ($extracting && ! $isZip)
            {
                $extracted = 1;
                if ($opt_Pipe)
                {
                    progress "  extracting: " . join("/", @unzip_path, $name)
                        if $opt_PipeWithName ;

                    my $buff;
                    my $status;
                    while (($status = $unzip->read($buff)) > 0)
                    {
                        print $buff;
                    }
                }
                else
                {
                    # Extract to filesystem

                    if ($opt_FixWindowsPath)
                    {
                        $fullname =~ s/^[a-zA-Z]://;
                        $fullname =~ s#\\#/#g ;
                    }

                    my $isDir = $fullname =~ s#/+$##;
                    $fullname = canonicalPath($fullname)
                        if ! $opt_UnsafePath;

                    my $newname;
                    if (chkReplace($fullname, \$newname))
                    {
                        my $path = dirname $newname;

                        progress "  extracting: $newname";
                        if (! -d $path)
                        {
                            mkpath($path)
                                if length $path;
                        }

                        if ($isDir)
                        {
                            mkpath($newname)
                        }
                        else
                        {
                            open my $fh, '>', $newname
                                or die "Cannot open '$newname: $!\n" ;
                            binmode $fh;

                            my $buff;
                            my $status;
                            while (($status = $unzip->read($buff)) > 0)
                            {
                                print $fh $buff;
                            }

                            close $fh;
                        }

                        SetTimestamp($newname, $dosTime, $extraFields) ;
                    }
                }
            }

            # Listing options
            if ($opt_One)
            {
                print $name . "\n" ;
            }
            elsif ($opt_List)
            {
                print join("/", @unzip_path, $name) . "\n";
            }

        }

        if ($isZip && ! $extracted)
        {
            my $newunzip = new IO::Uncompress::Unzip $unzip
                or die "Cannot open '$name': $UnzipError\n";
            # walk($newunzip, [@unzip_path, $extracting ? "$name.nested" : $name], 1);

            walk($newunzip, nestedName(\@unzip_path, $name), 1);

        }
    }
}

sub nestedName
{
    my $path = shift;
    my $name = shift ;

    # take a copy of the path
    my @path = @$path;
    if (! $opt_HideNestedZip)
    {
        $name = "$name.nested"
            if $extracting;
        push @path, $name ;
    }

    return \@path;
}

sub isZipFile
{
    my $fh = shift;
    my $name = shift ;

    use IO::Compress::Zip::Constants qw(ZIP_LOCAL_HDR_SIG);

    return 0
        unless $name =~ /$opt_ZipWildcards/;

    my $buffer ;
    # *$fh->{Pending} = ''; # TODO - fix in Base.pm
    $fh->read($buffer, 4);
    $fh->ungetc($buffer);

    return 0
        if length $buffer < 4 ;

    my $sig = unpack("V", $buffer) ;

    return $sig == ZIP_LOCAL_HDR_SIG ;
}

sub progress
{
    return if $opt_Quiet;
    print "$_\n" for @_ ;
}

sub SetTimestamp
{
    my $filename = shift ;
    my $dosTime = shift ;
    my $extraFields = shift ;

    my $atime ;
    my $mtime ;
    my $ctime ;



    my $extraSet;

    if ($extraFields)
    {
        # TODO - UX timestamps

        my %extra = map { $_->[0] => $_->[1] } @$extraFields;

        if ($extra{UT})
        {
            ($atime, $mtime, $ctime) = decode_UT($extra{UT}) ;
            ++ $extraSet;
        }
    }

    if (! $extraSet)
    {
        # default to the DOS time
        $atime = $mtime = $ctime = $dosTime;
    }

    utime $atime, $mtime, $filename;
}

sub decode_UT
{
    my $ut = shift ;

    my ($atime, $mtime, $ctime) ;

    my $flags = unpack "C", substr($ut, 0, 1);
    $ut = substr($ut, 1);

    if ($flags & 1)
    {
        $mtime = unpack "V", substr($ut, 0, 4);
        $ut = substr($ut, 4);
    }

    if ($flags & 2)
    {
        $atime = unpack "V", substr($ut, 0, 4);
        $ut = substr($ut, 4);
    }

    if ($flags & 4)
    {
        $ctime = unpack "V", substr($ut, 0, 4);
        $ut = substr($ut, 4);
    }

    return $atime, $mtime, $ctime  ;

}

# sub decode_UX
# {
#     my $len = shift;
#     my $context = shift;
#     my $inCentralHdr = $context->{InCentralDir} ;

#     return if $len == 0 ;

#     my ($data, $time) = read_V();
#     out2 $data, "Access Time",    Value_V($time) . " " . getTime($time) ;

#     ($data, $time) = read_V();
#     out2 $data, "Mod Time",    Value_V($time) . " " . getTime($time) ;

#     if (! $inCentralHdr ) {
#         out_v "  UID" ;
#         out_v "  GID";
#     }
# }

# sub decode_NTFS_Filetimes
# {
#     my $len = shift;
#     my $context = shift;

#     out_V "  Reserved";
#     out_v "  Tag1";
#     out_v "  Size1" ;

#     my ($m, $s1) = read_U64;
#     out $m, "  Mtime", Ntfs2Unix($m, $s1);

#     my ($c, $s2) = read_U64;
#     out $c, "  Ctime", Ntfs2Unix($m, $s2);

#     my ($a, $s3) = read_U64;
#     out $m, "  Atime", Ntfs2Unix($m, $s3);
# }

# sub Ntfs2Unix
# {
#     my $v = shift;
#     my $u64 = shift;

#     # NTFS offset is 19DB1DED53E8000

#     my $hex = Value_U64($u64) ;
#     my $NTFS_OFFSET = new U64 0x19DB1DE, 0xD53E8000 ;
#     $u64->subtract($NTFS_OFFSET);
#     my $elapse = $u64->get64bit();
#     my $ns = ($elapse % 10000000) * 100;
#     $elapse = int ($elapse/10000000);
#     return "$hex '" . localtime($elapse) .
#            " " . sprintf("%0dns'", $ns);
# }

sub globToRegex
{
    my $string = shift ;

    my $inGlob = '';

    my $noPreBS = '(?<!\\\)' ; # no preceding backslash
    my $metachars = '.?';
    my $matchMetaRE = '[' . quotemeta($metachars) . ']';
    $matchMetaRE = "(?:\\*{1,2}|$matchMetaRE)";

    my %mapping = (
                # wildcard  Wild-no-span  default
                '*'  => { 1 => '[^/]*',  0 => '.*' },
                '?'  => { 1 => '[^/]',   0 => '.'  },
                '.'  => { 1 => '\.',     0 => '\.' },
                '**' => { 1 => '.*',     0 => '.*' },
                # '[' => '([',
                # '(' => '(',
                # ')' => ')',
           );

    # Multiple concatenated *'s don't make sense
    #$string =~ s#\*\*+#*# ;

    # TODO -- Allow space to delimit patterns?
    #my @strings = split /\s+/, $string ;
    #for my $str (@strings)
    my $out = '';
    my $depth = 0 ;

    while ($string =~ s/(.*?)$noPreBS($matchMetaRE)//)
    {
        $out .= quotemeta($1) ;
        $out .= $mapping{$2}{$opt_Wild_No_Span}
            if defined $mapping{$2};
    }

    $out .= quotemeta($string);

    return $out;
}

sub chkReplace
{
    my $filename = shift ;
    my $newFilename = shift ;

    # default is not to rename
    $$newFilename = $filename;

    return 1 if $opt_Overwrite ;
    return 0 if $opt_NeverOverwrite;

    my $got = '';
    while (1)
    {
        return 1
            if ! -e $filename ;

        while (1)
        {
            print "replace $filename? [y]es, [n]o, [A]ll, [N]one, [r]ename: ";
            $got = <STDIN>;
            chomp $got;

            last
                if $got !~ /[ynANr]/ ;

            print "error: invaid response [$got]\n";
        }

        return 1 if $got eq 'y';
        return 0 if $got eq 'n';

        if ($got eq 'A')
        {
            $opt_Overwrite = 1 ;
            return 1 ;
        }

        if ($got eq 'N')
        {
            $opt_NeverOverwrite = 1 ;
            return 1 ;
        }

        if ($got eq 'r')
        {
            print "new name: ";

            $filename = <STDIN>;
            chomp $filename;
            $$newFilename = $filename;
        }
    }
}


sub canonicalPath
{
    my $name = shift ;

    # Not an absolute path
    $name =~ s#^/+## ;

    # Remove trailing slash
    # $name =~ s#/+$## ;

    $name =~ s#/+#/#g ;

    # Drop any ".." and "." paths
    # Use of ".." is unsafe
    my @paths = split '/', $name ;
    my @have =  grep { $_ ne '.' } @paths ;

    @have =  grep {  $_ ne '..' } @paths
        if ! $opt_UnsafePath;

    return join '/', @have ;

    # use Perl::OSType;
    # my $type = Perl::OSType::os_type();
    # if ( $type eq 'Unix' )
    # {
    # }
    # # TODO Win32
}

sub Usage
{
    die <<EOM;
Usage: nested-unzip [OPTIONS] file.zip [list]

Unzip a zip file that itself contains zip files, nested to any level.

OPTIONS

 -c       Extract file to stdout, prefix with name as extracting
 -d dest  Extract files into directory "dest".
 -h       Display help
 -p       Extract file to stdout (no filename prefix)
 -n       Never overwrite existing files
 -o       Silently overwrite existing files
 -q       Quiet
 -W       Modify pattern matching so ? and * do not match
          the directory separator /.

 --do-double-dots       Allow ".."
 --fix-windows-path     Remove drive letter & change path separator from "\" to "/"
 --hide-nested-zip      Don't include the nested zip filename in any output
 --version              Display version number ($VERSION) and exit
 --zip-wildcard w       Use Wildcard "w" when matching zip archives.
                        Default is @opt_ZipWildcards_Default

EOM
}

__END__
=head1 NAME

nested-unzip - uncompress zip files that also contain zip files

=head1 SYNOPSIS

    nested-unzip [opts] file.zip [list]

=head1 DESCRIPTION

This program is used to uncompress zip files that themselves contain other
zip files. Those nested zip files can in turn embed more zip files.  The
program can cope with Zip files nested to any depth.

To paraphrase the well-known poem "Siphonaptera"

    Nested zips have little zips upon their backs to bite 'em,
    And little zips have lesser zips, and so ad infinitum.

Where possible, and it makes sense, the interface has been written to match
the Linux unzip program.

The program works by reading the zip file in streaming mode, so no
temporary files are created when walking a nested tree of zip files.

=head2 Default Behaviour

The default behaviour of the program is to uncompress all the nested zip
files into a directory tree that mirrors the zip file. The directories
created for each of the nested zip files has the string ".nested" appended.

For security reasons, all paths that contain C<..> will be removed before
extraction. Use the C<--do-double-dots> option to override this behaviour.

=head2 OPTIONS

=over 5

=item -c

=item --to-stdout

Write the unzipped contents to stdout. Prefix with name as extracting.

=item -d dest_dir

=item --extract-dir dest_dir

Specifies a destination directory for extracted files. By default, files
are extracted (and subdirectories created) in the current  directory. When
this option is specified, extraction is done into the target directory,
C<dest_dir>. If the path C<dest_dir> does not exist, it will be created.

=item -l

=item --list

List the contents of the nested zip file.

=item -p

=item --pipe-to-stdout

Write the unzipped contents to stdout.

=item -W

=item --wild-no-span

Changes the behaviour of the wildcard matching so that the wildcard
characters C<?> and C<*> do not match the directory separator character
C</>.


=item  --do-double-dots

Normally this program will remove all C<..> path components before
extracting to the filesystem. This option disables that feature. Use with
extreme caution.

Note that the path created in the filesystem is platform dependent.

=item --hide-nested-zip

When extracting or listing the contents of a zip file that contains nested
zip files, the name of the nested zip files are included. This option make
it appear that the contents of the nested zip are in the directory where
the nested zip lives.

For example, if a zip contains the following

    a/b.zip/c1
    s/c2

Normally this will be extracted as

    a/b.zip.nested/c1
    s/c2

With this option the output becomes

    a/c1
    s/c2

=item  --fix-windows-path

When this option is enabled it will make the following changes to all
filenames before writing to the filesystem

=over 5

=item *
Remove any leading drive letter.

=item *
Convert all C<\> characters to C</>.

=back

For example

    Stored in Zip File  Output when "fix-windows-path" enabled
    ------------------  ------------------------------------
    c:\abc.txt          abc.txt
    one\two\three.txt   one/two/three.txt


See L<Dealing with Zip files that contain Windows Paths> for more details.


=item  --version

Display version number [$VERSION]

=item --zip-wildcard

By default the program will only check members of an archive that match the
wildcard C<**.zip> to see if they are zip archives.  There are other common
uses if the zip container format that this program can check. Examples
include Java C<.jar> and C<.war> files, Office files C<.docx>, C<.xlsx> etc.
the list goes on.  Use this option to speficy the the wildcards used when


For example, to only extract the contents of  Java jar/war files

    --zip-wildcard '**.jar' --zip-wildcard '**.war'

If you safely use the wildcard C<**> the program will check every memober
of the archive to see if it is a valid zip container. If it is, it will
extract it.

This option can be specified multiple times.

Defalut value is C<**.zip>.

=item --help

Display help

=back

=head2 Wildcard Matching

By default the program uses the standard Linux-stype wildcard

   *  Match zero or more characters
   ?  Match exactly one character
   ** Match zero or more characters

For example

    Wildcard
    *.c         Matches "foo.c" andt "mydir/foo.c"
    **.c        Matches "foo.c" and "mydir/foo.c"
    */*.c       Matches "abc/foo.c" and "abc/def/foo.c"
    ??*/*       Matches "ab/foo.c",  "abc/foo" and "a/b/foo"

If the C<-W>/C<--wild-no-span> option is present, the wildcard operators
C<*> and C<?> are modified to I<not> match against that path separator
C</>.  The C<**> sequence is not changed by the C<-W>/C<--wild-no-span>
option. It can I<always> match against the path seperator C</>.

For example

    Wildcard
    *.c         Matches "foo.c" but not "mydir/foo.c"
    **.c        Matches "foo.c" and "mydir/foo.c"
    */*.c       Matches "abc/foo.c" but not "abc/def/foo.c"
    ??*/*       Matches "ab/foo.c" and "abc/foo" but not "a/foo" or "a/b/foo"


=head1 FAQ

=head2 Dealing with Zip files that contain Windows Paths

Short answer - fix the problem by including the C<--fix-windows-path>
option when running this program.

Here is the longer answer.

A well-known problem with some zip implementations on Windows is they will
write a windows-native path into the zip file (e.g. C<C:\abc\def\my.txt>).

This is a badly-formed zip file. The Zip specification,
L<APPNOTE.TXT|https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT>,
is very clear on how paths should be stored in a zip file.

       4.4.17.1 The name of the file, with optional relative path.
       The path stored MUST NOT contain a drive or
       device letter, or a leading slash.  All slashes
       MUST be forward slashes '/' as opposed to
       backwards slashes '\' for compatibility with Amiga
       and UNIX file systems etc.  If input came from stanard
       input, there is no file name field.

The problem comes when unzipping one of these badly-formed zip files.
Consider the zip file C<bad.zip>, shown below, that contains a
windows-native path.

    $ unzip -l bad.zip
    Archive:  bad.zip
      Length      Date    Time    Name
    ---------  ---------- -----   ----
           27  03-10-2020 12:01   C:\abc\my.txt
    ---------                     -------
           27                     1 file

If this zipfile is extracted on a Linux-like operating system using the
standard unzip program, it will do the following

    $ unzip bad.zip
    Archive:  bad.zip
      inflating: C:\abc\my.txt

    $ ls -l *.txt
    -rw-r--r-- 1 xxx yyy 27 Mar 10 12:01 C:\abc\my.txt

Instead of creating a sub-directory C<abc> and storing C<my.txt> in that
directory, it thinks that the string C<C:\abc\my.txt> is the name of the
file.

The C<--fix-windows-path> option was designed to fix these paths. It will
convert all filnames into Linux/Unix format before writing to the
filesystem, by makes these changes

=over 5

=item *
Remove any leading drive letter.

=item *
Convert all C<\> characters to C</>.

=back

Using C<nested-unzip> with C<--fix-windows-path> to unzip C<bad.zip> we get

    $ ./bin/nested-unzip --fix-windows-path bad.zip
    Archive: bad.zip
      extracting: abc/def/my.txt

    $ find abc
    abc
    abc/def
    abc/def/my.txt

    $ ls -l abc/def/my.txt
    -rw-rw-r-- 1 xxx yyy 27 Mar 10 12:01 abc/def/my.txt

Although this option is primarily designed to be run on Unix/Linux derived
systems, the option can be enabled when running on Windows as well.

=head1 EXAMPLES

=head1 LIMITATIONS

=head1 SUPPORT

General feedback/questions/bug reports should be sent to
L<https://github.com/pmqs/IO-Compress/issues>.

=head1 AUTHOR

Paul Marquess F<pmqs@cpan.org>.

=head1 COPYRIGHT

Copyright (c) 2020 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
